# 프론트엔드 개발자를 위한 백엔드 이해 가이드

## 이 문서의 목적

DB나 백엔드 경험이 없는 프론트엔드 개발자가 이 프로젝트의 백엔드 구조를 이해하고, Server Actions를 활용할 수 있도록 돕는다.

---

## 1. 기본 개념

### 1.1 Supabase란?

**한 줄 요약**: Firebase 같은 BaaS(Backend as a Service)인데, PostgreSQL 기반이라 더 강력하다.

```
일반적인 백엔드        vs        Supabase
─────────────────────────────────────────────
Express/NestJS                 필요 없음
MySQL/PostgreSQL    →    PostgreSQL (내장)
JWT 인증 직접 구현    →    Supabase Auth (내장)
S3 연동              →    Supabase Storage (내장)
```

**우리가 하는 일**:
1. Supabase 콘솔에서 테이블 생성
2. Next.js에서 Supabase 클라이언트로 데이터 읽기/쓰기
3. 끝!

### 1.2 Server Actions란?

**한 줄 요약**: API 엔드포인트를 함수처럼 호출하는 Next.js 기능.

```typescript
// 예전 방식 (API Route)
// pages/api/addContent.ts
export default async function handler(req, res) {
  const data = JSON.parse(req.body)
  // ... 처리
  res.json({ success: true })
}

// 클라이언트에서
await fetch('/api/addContent', {
  method: 'POST',
  body: JSON.stringify(data)
})
```

```typescript
// Server Actions 방식
// actions/contents/addContent.ts
'use server'  // ← 이 한 줄이 핵심!

export async function addContent(data) {
  // ... 처리 (서버에서 실행됨)
  return { success: true }
}

// 클라이언트에서
import { addContent } from '@/actions/contents/addContent'
await addContent(data)  // 그냥 함수 호출!
```

**장점**:
- fetch 안 써도 됨
- TypeScript 타입이 자동으로 공유됨
- 에러 핸들링이 쉬움

### 1.3 RLS (Row Level Security)란?

**한 줄 요약**: 데이터베이스가 알아서 "이 유저는 이 데이터만 볼 수 있어"를 처리해준다.

```sql
-- 이런 정책을 설정하면
CREATE POLICY "users_select" ON users
FOR SELECT USING (id = auth.uid() OR is_public = true);
```

```typescript
// 이렇게 쿼리하면
const { data } = await supabase.from('users').select('*')

// 자동으로 필터링됨!
// - 로그인 안 했으면: is_public = true인 유저만
// - 로그인 했으면: 본인 + is_public = true인 유저들
```

**프론트엔드가 알아야 할 것**:
- 별도 필터링 코드 필요 없음
- 권한 없는 데이터는 애초에 안 옴
- 에러가 나면 `{ data: null, error: {...} }` 형태로 옴

---

## 2. 테이블 구조 이해하기

### 2.1 핵심 테이블 관계

```
users (사용자)
  │
  ├── user_contents (사용자의 콘텐츠) ─── contents (콘텐츠 마스터)
  │       │
  │       ├── reviews (리뷰)
  │       │     ├── review_likes (좋아요)
  │       │     └── review_comments (댓글)
  │       │
  │       └── notes (노트)
  │             └── note_sections (구획)
  │
  ├── follows (팔로우 관계)
  │
  └── user_scores (점수 캐시)
```

### 2.2 테이블 = JavaScript 객체

```typescript
// users 테이블
interface User {
  id: string           // UUID (고유 식별자)
  email: string
  username: string     // @username
  display_name: string // 화면에 표시되는 이름
  avatar_url: string | null
  bio: string | null
  is_public: boolean
  created_at: string   // ISO 날짜 문자열
  updated_at: string
}

// user_contents 테이블
interface UserContent {
  id: string
  user_id: string      // users.id 참조 (외래키)
  content_id: string   // contents.id 참조 (외래키)
  status: 'watching' | 'completed' | 'dropped' | 'wishlist'
  progress: number     // 0-100
  added_at: string
  updated_at: string
}
```

### 2.3 외래키(Foreign Key) 이해하기

```typescript
// user_contents.user_id는 users.id를 참조한다
// = "이 콘텐츠는 누구 꺼야?"에 대한 답

// 실제 데이터 예시:
const user = { id: 'abc-123', username: 'john' }
const userContent = { id: 'xyz-789', user_id: 'abc-123', content_id: 'def-456' }
//                                   ↑ 여기가 user.id와 같음

// Supabase에서 조인하면:
const { data } = await supabase
  .from('user_contents')
  .select(`
    *,
    user:users!user_id (*)  // user_id로 users 테이블 조인
  `)

// 결과:
// {
//   id: 'xyz-789',
//   user_id: 'abc-123',
//   user: { id: 'abc-123', username: 'john', ... }  // 조인된 데이터!
// }
```

### 2.4 ENUM 타입

```sql
-- 데이터베이스에서 허용되는 값을 제한
CREATE TYPE content_status AS ENUM ('watching', 'completed', 'dropped', 'wishlist');
```

```typescript
// TypeScript에서는 이렇게 표현
type ContentStatus = 'watching' | 'completed' | 'dropped' | 'wishlist'

// 잘못된 값 넣으면 DB 에러남
await supabase.from('user_contents').insert({
  status: 'invalid'  // ❌ 에러!
})
```

### 2.5 JSONB 타입

```sql
-- 구조화된 데이터를 하나의 컬럼에 저장
metadata JSONB DEFAULT '{}'
```

```typescript
// 그냥 JavaScript 객체처럼 사용
const content = {
  metadata: {
    publisher: '문학동네',
    pageCount: 320,
    isbn: '978-89-...'
  }
}

// 조회할 때도 객체로 옴
const { data } = await supabase.from('contents').select('metadata')
console.log(data.metadata.publisher)  // '문학동네'
```

---

## 3. Supabase 클라이언트 사용법

### 3.1 클라이언트 종류

```typescript
// 1. 브라우저용 (클라이언트 컴포넌트에서)
// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// 사용: 'use client' 컴포넌트에서
const supabase = createClient()
```

```typescript
// 2. 서버용 (Server Actions, Server Components에서)
// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            cookieStore.set(name, value, options)
          })
        }
      }
    }
  )
}

// 사용: Server Action에서
'use server'
export async function myAction() {
  const supabase = await createClient()  // await 필요!
}
```

### 3.2 CRUD 기본

```typescript
// CREATE (생성)
const { data, error } = await supabase
  .from('reviews')
  .insert({
    user_id: 'abc-123',
    content_id: 'def-456',
    rating: 4.5,
    text: '좋았습니다'
  })
  .select()  // 생성된 데이터 반환받기
  .single()  // 단일 객체로 반환 (배열 X)

// READ (조회)
const { data, error } = await supabase
  .from('reviews')
  .select('*')  // 모든 컬럼
  .eq('user_id', 'abc-123')  // WHERE user_id = 'abc-123'
  .order('created_at', { ascending: false })  // 최신순
  .limit(10)

// UPDATE (수정)
const { data, error } = await supabase
  .from('reviews')
  .update({ rating: 5.0 })
  .eq('id', 'xyz-789')

// DELETE (삭제)
const { data, error } = await supabase
  .from('reviews')
  .delete()
  .eq('id', 'xyz-789')
```

### 3.3 조인(Join) - 관계된 테이블 함께 조회

```typescript
// reviews 조회할 때 user 정보도 함께 가져오기
const { data } = await supabase
  .from('reviews')
  .select(`
    id,
    rating,
    text,
    created_at,
    user:users!user_id (
      id,
      username,
      display_name,
      avatar_url
    ),
    content:contents!content_id (
      id,
      title,
      cover_image_url
    )
  `)
  .eq('visibility', 'public')

// 결과:
// {
//   id: 'xyz-789',
//   rating: 4.5,
//   text: '좋았습니다',
//   user: { id: 'abc', username: 'john', ... },
//   content: { id: 'def', title: '해리포터', ... }
// }
```

### 3.4 필터 조건들

```typescript
.eq('status', 'completed')     // status = 'completed'
.neq('status', 'dropped')      // status != 'dropped'
.gt('rating', 4)               // rating > 4
.gte('rating', 4)              // rating >= 4
.lt('rating', 3)               // rating < 3
.lte('rating', 3)              // rating <= 3
.like('title', '%해리%')        // title LIKE '%해리%'
.ilike('title', '%해리%')       // 대소문자 무시
.in('status', ['watching', 'completed'])  // status IN (...)
.is('deleted_at', null)        // deleted_at IS NULL
.not('user_id', 'in', ['a', 'b'])  // user_id NOT IN (...)
```

### 3.5 에러 핸들링

```typescript
const { data, error } = await supabase.from('reviews').select('*')

if (error) {
  // 에러 구조
  // {
  //   message: "에러 메시지",
  //   code: "23505",  // PostgreSQL 에러 코드
  //   details: "...",
  //   hint: "..."
  // }

  // 자주 보는 에러 코드
  switch (error.code) {
    case '23505':  // unique_violation
      throw new Error('이미 존재합니다')
    case '23503':  // foreign_key_violation
      throw new Error('참조하는 데이터가 없습니다')
    case '42501':  // insufficient_privilege (RLS)
      throw new Error('권한이 없습니다')
    default:
      throw new Error(error.message)
  }
}
```

---

## 4. Server Action 작성법

### 4.1 기본 구조

```typescript
// src/actions/reviews/createReview.ts
'use server'  // 필수! 이게 있어야 서버에서 실행됨

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

// 파라미터 타입 정의
interface CreateReviewParams {
  contentId: string
  rating?: number
  text?: string
}

// 반환 타입 정의
interface CreateReviewResult {
  reviewId: string
}

export async function createReview(
  params: CreateReviewParams
): Promise<CreateReviewResult> {
  // 1. Supabase 클라이언트 생성
  const supabase = await createClient()

  // 2. 현재 로그인한 유저 확인
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    throw new Error('로그인이 필요합니다')
  }

  // 3. 데이터 삽입
  const { data, error } = await supabase
    .from('reviews')
    .insert({
      user_id: user.id,
      content_id: params.contentId,
      rating: params.rating,
      text: params.text
    })
    .select('id')
    .single()

  if (error) {
    if (error.code === '23505') {
      throw new Error('이미 리뷰를 작성했습니다')
    }
    throw new Error('리뷰 작성에 실패했습니다')
  }

  // 4. 캐시 갱신 (해당 페이지 새로고침 없이 데이터 반영)
  revalidatePath(`/archive/${params.contentId}`)

  // 5. 결과 반환
  return { reviewId: data.id }
}
```

### 4.2 클라이언트에서 호출

```typescript
// 방법 1: 직접 호출 (useTransition)
'use client'

import { useTransition } from 'react'
import { createReview } from '@/actions/reviews/createReview'

export function ReviewForm({ contentId }: { contentId: string }) {
  const [isPending, startTransition] = useTransition()

  const handleSubmit = (formData: FormData) => {
    startTransition(async () => {
      try {
        const result = await createReview({
          contentId,
          rating: Number(formData.get('rating')),
          text: formData.get('text') as string
        })
        console.log('생성됨:', result.reviewId)
      } catch (error) {
        console.error('에러:', error.message)
      }
    })
  }

  return (
    <form action={handleSubmit}>
      <input name="rating" type="number" step="0.5" />
      <textarea name="text" />
      <button disabled={isPending}>
        {isPending ? '저장 중...' : '저장'}
      </button>
    </form>
  )
}
```

```typescript
// 방법 2: form action에 바로 전달
'use client'

import { createReview } from '@/actions/reviews/createReview'

export function ReviewForm({ contentId }: { contentId: string }) {
  // bind로 contentId를 미리 바인딩
  const createReviewWithId = createReview.bind(null, { contentId })

  return (
    <form action={async (formData) => {
      await createReviewWithId({
        contentId,
        rating: Number(formData.get('rating')),
        text: formData.get('text') as string
      })
    }}>
      ...
    </form>
  )
}
```

### 4.3 에러 처리 패턴

```typescript
// actions/reviews/createReview.ts
'use server'

export async function createReview(params: CreateReviewParams) {
  try {
    // ... 로직
    return { success: true, data: result }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : '알 수 없는 에러'
    }
  }
}

// 클라이언트
const result = await createReview(params)

if (!result.success) {
  toast.error(result.error)
  return
}

toast.success('저장되었습니다')
```

---

## 5. 인증 흐름

### 5.1 로그인 과정

```
1. 유저가 "Google로 로그인" 클릭
2. Server Action 실행 → Supabase Auth가 Google OAuth URL 생성
3. Google 로그인 페이지로 리다이렉트
4. 유저가 Google에서 로그인
5. /auth/callback으로 돌아옴 (code 파라미터 포함)
6. code를 세션으로 교환
7. 쿠키에 세션 저장
8. /dashboard로 리다이렉트
```

### 5.2 세션 확인

```typescript
// Server Action이나 Server Component에서
const supabase = await createClient()
const { data: { user } } = await supabase.auth.getUser()

if (user) {
  console.log('로그인됨:', user.id, user.email)
} else {
  console.log('비로그인')
}
```

```typescript
// 클라이언트 컴포넌트에서
'use client'

import { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'

export function useUser() {
  const [user, setUser] = useState(null)
  const supabase = createClient()

  useEffect(() => {
    supabase.auth.getUser().then(({ data }) => {
      setUser(data.user)
    })
  }, [])

  return user
}
```

### 5.3 Middleware로 보호된 라우트

```typescript
// src/middleware.ts

// 이 경로들은 로그인 필요
const protectedPaths = ['/dashboard', '/archive', '/feed']

export async function middleware(request) {
  const user = await getUser(request)  // 세션에서 유저 확인

  if (protectedPaths.some(path => request.pathname.startsWith(path))) {
    if (!user) {
      // 로그인 페이지로 리다이렉트
      return NextResponse.redirect('/login')
    }
  }

  return NextResponse.next()
}
```

---

## 6. 실전 예제

### 6.1 기록관 목록 조회

```typescript
// actions/contents/getMyContents.ts
'use server'

interface GetMyContentsParams {
  status?: string
  category?: string
  cursor?: string
  limit?: number
}

export async function getMyContents({
  status,
  category,
  cursor,
  limit = 20
}: GetMyContentsParams = {}) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) throw new Error('Unauthorized')

  // 쿼리 빌드
  let query = supabase
    .from('user_contents')
    .select(`
      id,
      status,
      progress,
      added_at,
      content:contents!content_id (
        id,
        category,
        title,
        creator,
        cover_image_url
      ),
      review:reviews!inner (
        rating
      )
    `, { count: 'exact' })  // 전체 개수도 반환
    .eq('user_id', user.id)
    .order('added_at', { ascending: false })
    .limit(limit)

  // 필터 적용
  if (status) {
    query = query.eq('status', status)
  }

  if (category) {
    query = query.eq('content.category', category)
  }

  if (cursor) {
    query = query.lt('added_at', cursor)
  }

  const { data, error, count } = await query

  if (error) throw error

  return {
    items: data,
    total: count,
    nextCursor: data.length === limit
      ? data[data.length - 1].added_at
      : null
  }
}
```

```typescript
// 페이지에서 사용
// app/(main)/archive/page.tsx

import { getMyContents } from '@/actions/contents/getMyContents'

export default async function ArchivePage({
  searchParams
}: {
  searchParams: { status?: string; category?: string }
}) {
  const { items, total } = await getMyContents({
    status: searchParams.status,
    category: searchParams.category
  })

  return (
    <div>
      <p>총 {total}개</p>
      {items.map(item => (
        <ContentCard key={item.id} content={item} />
      ))}
    </div>
  )
}
```

### 6.2 좋아요 토글

```typescript
// actions/reviews/likeReview.ts
'use server'

export async function likeReview(reviewId: string) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) throw new Error('Unauthorized')

  // 이미 좋아요 했는지 확인
  const { data: existing } = await supabase
    .from('review_likes')
    .select('id')
    .eq('review_id', reviewId)
    .eq('user_id', user.id)
    .single()

  if (existing) {
    // 좋아요 취소
    await supabase
      .from('review_likes')
      .delete()
      .eq('id', existing.id)

    // 카운트 감소
    await supabase
      .from('reviews')
      .update({
        like_count: supabase.sql`like_count - 1`
      })
      .eq('id', reviewId)

    return { liked: false }
  } else {
    // 좋아요
    await supabase
      .from('review_likes')
      .insert({
        review_id: reviewId,
        user_id: user.id
      })

    // 카운트 증가
    await supabase
      .from('reviews')
      .update({
        like_count: supabase.sql`like_count + 1`
      })
      .eq('id', reviewId)

    return { liked: true }
  }
}
```

```typescript
// 컴포넌트에서 사용
'use client'

import { likeReview } from '@/actions/reviews/likeReview'
import { useState, useTransition } from 'react'
import { Heart } from 'lucide-react'

export function LikeButton({
  reviewId,
  initialLiked,
  initialCount
}: {
  reviewId: string
  initialLiked: boolean
  initialCount: number
}) {
  const [liked, setLiked] = useState(initialLiked)
  const [count, setCount] = useState(initialCount)
  const [isPending, startTransition] = useTransition()

  const handleClick = () => {
    // 낙관적 업데이트 (즉시 UI 변경)
    setLiked(!liked)
    setCount(liked ? count - 1 : count + 1)

    startTransition(async () => {
      try {
        const result = await likeReview(reviewId)
        // 서버 결과로 동기화
        setLiked(result.liked)
      } catch {
        // 실패 시 롤백
        setLiked(liked)
        setCount(count)
      }
    })
  }

  return (
    <button onClick={handleClick} disabled={isPending}>
      <Heart fill={liked ? 'red' : 'none'} />
      {count}
    </button>
  )
}
```

---

## 7. 디버깅 팁

### 7.1 Supabase 쿼리 로그

```typescript
// 개발 중 쿼리 확인
const { data, error } = await supabase
  .from('reviews')
  .select('*')
  .eq('user_id', userId)

console.log('Query result:', { data, error })
```

### 7.2 RLS 디버깅

RLS 때문에 데이터가 안 보일 때:

```typescript
// Supabase 콘솔 > SQL Editor에서
SELECT * FROM reviews WHERE user_id = '...'  -- RLS 무시됨

// 또는 Service Role Key 사용 (주의: 보안!)
import { createAdminClient } from '@/lib/supabase/admin'
const supabase = createAdminClient()  // RLS 무시
```

### 7.3 타입 생성

```bash
# Supabase에서 TypeScript 타입 자동 생성
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > src/types/database.ts
```

```typescript
// 사용
import { Database } from '@/types/database'

type Review = Database['public']['Tables']['reviews']['Row']
type InsertReview = Database['public']['Tables']['reviews']['Insert']
```

---

## 8. 자주 묻는 질문

### Q: Server Action에서 redirect가 안 돼요

```typescript
// ❌ 이렇게 하면 안 됨
'use server'
export async function login() {
  // ...
  redirect('/dashboard')  // 에러!
}

// ✅ 이렇게
import { redirect } from 'next/navigation'

'use server'
export async function login() {
  // ...
  redirect('/dashboard')  // OK (try-catch 밖에서)
}
```

### Q: revalidatePath가 뭔가요?

Next.js는 서버 컴포넌트를 캐싱한다. 데이터가 바뀌면 캐시를 무효화해야 한다.

```typescript
revalidatePath('/archive')  // /archive 페이지 캐시 무효화
revalidatePath('/archive/[id]', 'page')  // 동적 라우트
revalidatePath('/', 'layout')  // 레이아웃 포함 전체
```

### Q: 로그인 상태를 어떻게 유지하나요?

Supabase가 쿠키로 세션을 관리한다. 토큰 갱신도 자동.
Middleware에서 세션 체크 → 만료되면 자동 갱신.

### Q: 에러 메시지를 사용자에게 어떻게 보여주나요?

```typescript
// Server Action
export async function createReview(params) {
  try {
    // ...
  } catch (error) {
    // 사용자에게 보여줄 메시지
    return { error: '리뷰 작성에 실패했습니다' }
  }
}

// 클라이언트
const result = await createReview(params)
if (result.error) {
  toast.error(result.error)
}
```

---

*가이드_프론트엔드_개발자를_위한_백엔드_이해.md*
