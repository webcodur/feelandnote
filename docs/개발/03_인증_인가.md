# Feel&Note 인증/인가 설계

## 개요

Supabase Auth 기반 인증. OAuth 소셜 로그인 + Row Level Security(RLS) 기반 인가.

---

## 인증 방식

### 지원 로그인

| 방식 | Provider | 우선순위 |
|------|----------|----------|
| Google | google | Phase 1 |
| Kakao | kakao | Phase 1 |
| Email/Password | email | Phase 2 (선택) |

### 인증 흐름

```
┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
│ Client  │────>│ Next.js │────>│Supabase │────>│ OAuth   │
│         │     │         │     │  Auth   │     │Provider │
└─────────┘     └─────────┘     └─────────┘     └─────────┘
     │                               │               │
     │  1. 로그인 버튼 클릭          │               │
     │──────────────────────────────>│               │
     │                               │               │
     │  2. OAuth URL 리다이렉트      │               │
     │<──────────────────────────────│               │
     │                               │               │
     │  3. 사용자 인증               │               │
     │──────────────────────────────────────────────>│
     │                               │               │
     │  4. 인증 완료, 콜백 리다이렉트 │               │
     │<──────────────────────────────────────────────│
     │                               │               │
     │  5. 세션 토큰 발급            │               │
     │<──────────────────────────────│               │
     │                               │               │
     │  6. 프로필 정보 저장/갱신     │               │
     │──────────────────────────────>│               │
     └───────────────────────────────┘               │
```

---

## Supabase 설정

### 환경 변수

```env
# .env.local

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://wouqtpvfctednlffross.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=xxx

# OAuth - Google
GOOGLE_CLIENT_ID=xxx.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=xxx

# OAuth - Kakao
KAKAO_CLIENT_ID=xxx
KAKAO_CLIENT_SECRET=xxx

# App
NEXT_PUBLIC_SITE_URL=http://localhost:3000
```

---

## Next.js 구현

### Supabase 클라이언트

#### 브라우저 클라이언트

```typescript
// src/lib/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

#### 서버 클라이언트

```typescript
// src/lib/supabase/server.ts

import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options)
            })
          } catch {
            // Server Component에서 호출 시 무시
          }
        }
      }
    }
  )
}
```

### Middleware

```typescript
// src/middleware.ts

import { NextResponse, type NextRequest } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

// 인증이 필요한 경로
const protectedPaths = [
  '/dashboard',
  '/archive',
  '/settings'
]

// 인증된 사용자가 접근하면 안 되는 경로
const authPaths = ['/login', '/signup']

export async function middleware(request: NextRequest) {
  const { supabaseResponse, user } = await updateSession(request)

  const pathname = request.nextUrl.pathname

  // 보호된 경로에 비인증 사용자 접근 시
  if (protectedPaths.some((path) => pathname.startsWith(path))) {
    if (!user) {
      const url = request.nextUrl.clone()
      url.pathname = '/login'
      url.searchParams.set('redirect', pathname)
      return NextResponse.redirect(url)
    }
  }

  // 인증 경로에 인증된 사용자 접근 시
  if (authPaths.some((path) => pathname.startsWith(path))) {
    if (user) {
      const url = request.nextUrl.clone()
      url.pathname = '/dashboard'
      return NextResponse.redirect(url)
    }
  }

  return supabaseResponse
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'
  ]
}
```

### Auth Callback

```typescript
// src/app/auth/callback/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  const { searchParams, origin } = request.nextUrl
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createClient()

    const { data, error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error && data.user) {
      // 신규 사용자인 경우 프로필 생성
      const { data: existingProfile } = await supabase
        .from('profiles')
        .select('id')
        .eq('id', data.user.id)
        .single()

      if (!existingProfile) {
        await supabase.from('profiles').insert({
          id: data.user.id,
          email: data.user.email,
          nickname: data.user.user_metadata.full_name || data.user.user_metadata.name,
          avatar_url: data.user.user_metadata.avatar_url || data.user.user_metadata.picture
        })
      }

      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // 에러 발생 시 로그인 페이지로
  return NextResponse.redirect(`${origin}/login?error=auth_failed`)
}
```

### Auth Actions

```typescript
// src/actions/auth/login.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export async function loginWithGoogle() {
  const supabase = await createClient()

  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`,
      queryParams: {
        access_type: 'offline',
        prompt: 'consent'
      }
    }
  })

  if (error) {
    throw new Error(error.message)
  }

  redirect(data.url)
}

export async function loginWithKakao() {
  const supabase = await createClient()

  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'kakao',
    options: {
      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`
    }
  })

  if (error) {
    throw new Error(error.message)
  }

  redirect(data.url)
}
```

```typescript
// src/actions/auth/logout.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export async function logout() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  redirect('/login')
}
```

---

## 인가 (Authorization)

### Row Level Security (RLS)

Supabase의 RLS를 사용하여 데이터 접근 제어.

#### RLS 정책 원칙

| 정책 | 설명 |
|------|------|
| 소유자 전용 | 본인의 데이터만 접근 가능 |
| 공개 데이터 | 모든 사용자 조회 가능 |

#### profiles 테이블 RLS

```sql
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- SELECT: 모두 조회 가능
CREATE POLICY "Public profiles are viewable by everyone." ON profiles
FOR SELECT USING (true);

-- INSERT: 본인만
CREATE POLICY "Users can insert their own profile." ON profiles
FOR INSERT WITH CHECK (auth.uid() = id);

-- UPDATE: 본인만
CREATE POLICY "Users can update own profile." ON profiles
FOR UPDATE USING (auth.uid() = id);
```

#### contents 테이블 RLS

```sql
ALTER TABLE contents ENABLE ROW LEVEL SECURITY;

-- SELECT: 모두 조회 가능
CREATE POLICY "Contents are viewable by everyone." ON contents
FOR SELECT USING (true);

-- INSERT: 인증된 사용자
CREATE POLICY "Authenticated users can insert contents." ON contents
FOR INSERT WITH CHECK (auth.role() = 'authenticated');
```

#### user_contents 테이블 RLS

```sql
ALTER TABLE user_contents ENABLE ROW LEVEL SECURITY;

-- SELECT: 본인만
CREATE POLICY "Users can view own archive." ON user_contents
FOR SELECT USING (auth.uid() = user_id);

-- INSERT: 본인만
CREATE POLICY "Users can insert into own archive." ON user_contents
FOR INSERT WITH CHECK (auth.uid() = user_id);

-- UPDATE: 본인만
CREATE POLICY "Users can update own archive." ON user_contents
FOR UPDATE USING (auth.uid() = user_id);

-- DELETE: 본인만
CREATE POLICY "Users can delete from own archive." ON user_contents
FOR DELETE USING (auth.uid() = user_id);
```

#### records 테이블 RLS

```sql
ALTER TABLE records ENABLE ROW LEVEL SECURITY;

-- SELECT: 본인만
CREATE POLICY "Users can view own records." ON records
FOR SELECT USING (auth.uid() = user_id);

-- INSERT: 본인만
CREATE POLICY "Users can insert own records." ON records
FOR INSERT WITH CHECK (auth.uid() = user_id);

-- UPDATE: 본인만
CREATE POLICY "Users can update own records." ON records
FOR UPDATE USING (auth.uid() = user_id);

-- DELETE: 본인만
CREATE POLICY "Users can delete own records." ON records
FOR DELETE USING (auth.uid() = user_id);
```

---

## 보안 고려사항

### CSRF 방지

- Supabase Auth는 PKCE flow 사용
- Server Actions는 Next.js 내장 CSRF 보호

### 토큰 보안

- Access Token: 1시간 만료
- Refresh Token: 7일 만료 (자동 갱신)
- HttpOnly 쿠키 저장

---

*03_인증_인가.md*
