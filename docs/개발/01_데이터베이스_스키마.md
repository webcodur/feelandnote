# Feel&Note 데이터베이스 스키마

## 개요

Supabase (PostgreSQL) 기반 스키마. Row Level Security(RLS) 적용.

---

## ERD 개요

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  profiles   │────<│user_contents│>────│  contents   │
└─────────────┘     └─────────────┘     └─────────────┘
       │                   │
       │                   ▼
       │            ┌─────────────┐
       └───────────>│   records   │
                    └─────────────┘

┌─────────────┐     ┌─────────────┐
│  follows    │     │   blocks    │
└─────────────┘     └─────────────┘
       │                   │
       └───────┬───────────┘
               ▼
        ┌─────────────┐
        │ user_social │ (캐시)
        └─────────────┘

┌─────────────┐     ┌─────────────┐
│   titles    │────<│ user_titles │
└─────────────┘     └─────────────┘

┌─────────────┐     ┌─────────────┐
│ user_scores │     │ score_logs  │
└─────────────┘     └─────────────┘

┌─────────────┐     ┌───────────────────┐
│ tier_lists  │     │ blind_game_scores │
└─────────────┘     └───────────────────┘

┌──────────────┐    ┌──────────────────┐
│ record_likes │    │ record_comments  │
└──────────────┘    └──────────────────┘
```

---

## Phase 1: 핵심 테이블

### 1. profiles (사용자 프로필)

Supabase Auth의 `auth.users`를 확장하는 public 테이블.

```sql
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT,
  nickname TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL
);

-- RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public profiles are viewable by everyone."
  ON profiles FOR SELECT USING (true);

CREATE POLICY "Users can insert their own profile."
  ON profiles FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile."
  ON profiles FOR UPDATE USING (auth.uid() = id);
```

### 2. contents (콘텐츠)

모든 카테고리의 콘텐츠 통합 테이블. 외부 API ID를 PK로 사용.

```sql
CREATE TABLE public.contents (
  id TEXT PRIMARY KEY,                -- 외부 API ID (예: aladin ISBN, TMDB ID)
  type TEXT NOT NULL CHECK (type IN ('BOOK', 'MOVIE')),
  title TEXT NOT NULL,
  creator TEXT,                       -- 저자/감독
  thumbnail_url TEXT,
  description TEXT,
  publisher TEXT,
  release_date TEXT,
  metadata JSONB DEFAULT '{}',        -- 카테고리별 추가 메타데이터
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL
);

-- RLS
ALTER TABLE contents ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Contents are viewable by everyone."
  ON contents FOR SELECT USING (true);

CREATE POLICY "Authenticated users can insert contents."
  ON contents FOR INSERT WITH CHECK (auth.role() = 'authenticated');
```

#### type 값
- `BOOK`: 도서
- `MOVIE`: 영화

#### metadata JSONB 구조

```typescript
// 도서 (BOOK)
{
  isbn?: string;
  pageCount?: number;
  categoryName?: string;
}

// 영화 (MOVIE)
{
  runtime?: number;
  genres?: string[];
  cast?: string[];
  overview?: string;
}
```

### 3. user_contents (사용자-콘텐츠 관계)

```sql
CREATE TABLE public.user_contents (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  content_id TEXT NOT NULL REFERENCES contents(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('WISH', 'EXPERIENCE')),
  progress INTEGER DEFAULT 0,
  progress_type TEXT DEFAULT 'PERCENT' CHECK (progress_type IN ('PERCENT', 'PAGE', 'TIME')),
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL,

  UNIQUE(user_id, content_id)
);

-- RLS
ALTER TABLE user_contents ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own archive."
  ON user_contents FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert into own archive."
  ON user_contents FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own archive."
  ON user_contents FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete from own archive."
  ON user_contents FOR DELETE USING (auth.uid() = user_id);
```

#### status 값
- `WISH`: 보고 싶은 / 읽고 싶은
- `EXPERIENCE`: 경험 중 / 경험 완료

#### progress_type 값
- `PERCENT`: 백분율 (0-100)
- `PAGE`: 페이지 수
- `TIME`: 시간 (분)

### 4. records (기록)

리뷰, 노트, 인용구를 통합 관리하는 테이블.

```sql
CREATE TABLE public.records (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  content_id TEXT NOT NULL REFERENCES contents(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('REVIEW', 'NOTE', 'QUOTE')),
  content TEXT NOT NULL,              -- 기록 본문
  rating NUMERIC,                     -- 별점 (REVIEW 타입에서 사용)
  location TEXT,                      -- 위치 정보 (페이지, 챕터 등)
  visibility TEXT DEFAULT 'public' CHECK (visibility IN ('public', 'followers', 'private')),
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL
);

-- RLS
ALTER TABLE records ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own records."
  ON records FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own records."
  ON records FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own records."
  ON records FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own records."
  ON records FOR DELETE USING (auth.uid() = user_id);
```

#### type 값
- `REVIEW`: 리뷰 (별점 포함 가능)
- `NOTE`: 메모/노트
- `QUOTE`: 인용구

#### visibility 값
- `public`: 전체 공개
- `followers`: 팔로워 공개
- `private`: 비공개

---

## Phase 3: 소셜 테이블

### 5. follows (팔로우 관계)

```sql
CREATE TABLE public.follows (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  follower_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()),

  CONSTRAINT no_self_follow CHECK (follower_id != following_id),
  CONSTRAINT unique_follow UNIQUE (follower_id, following_id)
);

CREATE INDEX idx_follows_follower ON follows(follower_id);
CREATE INDEX idx_follows_following ON follows(following_id);

-- RLS
ALTER TABLE follows ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view follows"
  ON follows FOR SELECT USING (true);

CREATE POLICY "Users can follow others"
  ON follows FOR INSERT WITH CHECK (auth.uid() = follower_id);

CREATE POLICY "Users can unfollow"
  ON follows FOR DELETE USING (auth.uid() = follower_id);
```

### 6. blocks (차단 관계)

```sql
CREATE TABLE public.blocks (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  blocker_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  blocked_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()),

  CONSTRAINT no_self_block CHECK (blocker_id != blocked_id),
  CONSTRAINT unique_block UNIQUE (blocker_id, blocked_id)
);

CREATE INDEX idx_blocks_blocker ON blocks(blocker_id);
CREATE INDEX idx_blocks_blocked ON blocks(blocked_id);

-- RLS
ALTER TABLE blocks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own blocks"
  ON blocks FOR SELECT USING (auth.uid() = blocker_id);

CREATE POLICY "Users can block others"
  ON blocks FOR INSERT WITH CHECK (auth.uid() = blocker_id);

CREATE POLICY "Users can unblock"
  ON blocks FOR DELETE USING (auth.uid() = blocker_id);
```

### 7. user_social (소셜 캐시)

팔로워/팔로잉/친구 수와 영향력 캐시.

```sql
CREATE TABLE public.user_social (
  user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,
  friend_count INTEGER DEFAULT 0,
  follower_count INTEGER DEFAULT 0,
  following_count INTEGER DEFAULT 0,
  influence INTEGER DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

-- RLS
ALTER TABLE user_social ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view user_social"
  ON user_social FOR SELECT USING (true);

CREATE POLICY "System can manage user_social"
  ON user_social FOR ALL USING (auth.uid() = user_id);
```

### 8. record_likes (기록 좋아요)

```sql
CREATE TABLE public.record_likes (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  record_id UUID NOT NULL REFERENCES records(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()),

  UNIQUE(record_id, user_id)
);

CREATE INDEX idx_record_likes_record ON record_likes(record_id);

-- RLS
ALTER TABLE record_likes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view record_likes"
  ON record_likes FOR SELECT USING (true);

CREATE POLICY "Users can like records"
  ON record_likes FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can unlike"
  ON record_likes FOR DELETE USING (auth.uid() = user_id);
```

### 9. record_comments (기록 댓글)

```sql
CREATE TABLE public.record_comments (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  record_id UUID NOT NULL REFERENCES records(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  parent_id UUID REFERENCES record_comments(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()),
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

CREATE INDEX idx_record_comments_record ON record_comments(record_id);
CREATE INDEX idx_record_comments_parent ON record_comments(parent_id);

-- RLS
ALTER TABLE record_comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view comments"
  ON record_comments FOR SELECT USING (true);

CREATE POLICY "Users can add comments"
  ON record_comments FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own comments"
  ON record_comments FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own comments"
  ON record_comments FOR DELETE USING (auth.uid() = user_id);
```

---

## Phase 4: 게이미피케이션 테이블

### 10. user_scores (점수 캐시)

```sql
CREATE TABLE public.user_scores (
  user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,
  activity_score INTEGER DEFAULT 0,
  title_bonus INTEGER DEFAULT 0,
  total_score INTEGER DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

-- RLS
ALTER TABLE user_scores ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view user_scores"
  ON user_scores FOR SELECT USING (true);

CREATE POLICY "System can manage user_scores"
  ON user_scores FOR ALL USING (auth.uid() = user_id);
```

### 11. score_logs (점수 이력)

```sql
CREATE TABLE public.score_logs (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('activity', 'title')),
  action TEXT NOT NULL,
  amount INTEGER NOT NULL,
  reference_id TEXT,                  -- 관련 콘텐츠/기록 ID
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

CREATE INDEX idx_score_logs_user ON score_logs(user_id, created_at DESC);

-- RLS
ALTER TABLE score_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own score_logs"
  ON score_logs FOR SELECT USING (auth.uid() = user_id);
```

### 12. titles (칭호 정의)

```sql
CREATE TABLE public.titles (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  name TEXT NOT NULL UNIQUE,
  description TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('volume', 'diversity', 'consistency', 'depth', 'social', 'special')),
  grade TEXT NOT NULL CHECK (grade IN ('common', 'uncommon', 'rare', 'epic', 'legendary')),
  bonus_score INTEGER NOT NULL,
  condition JSONB NOT NULL,           -- 해금 조건 (내부용)
  sort_order INTEGER DEFAULT 0
);

-- RLS
ALTER TABLE titles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view titles"
  ON titles FOR SELECT USING (true);
```

#### category 값
- `volume`: 기록량 계열
- `diversity`: 다양성 계열
- `consistency`: 꾸준함 계열
- `depth`: 깊이 계열
- `social`: 소셜 계열
- `special`: 특수 계열 (이스터에그)

#### grade 값
- `common`: 일반 (+20점)
- `uncommon`: 고급 (+50점)
- `rare`: 희귀 (+100점)
- `epic`: 영웅 (+200점)
- `legendary`: 전설 (+500점)

### 13. user_titles (유저 칭호)

```sql
CREATE TABLE public.user_titles (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  title_id UUID NOT NULL REFERENCES titles(id) ON DELETE CASCADE,
  unlocked_at TIMESTAMPTZ DEFAULT timezone('utc', now()),

  UNIQUE(user_id, title_id)
);

CREATE INDEX idx_user_titles_user ON user_titles(user_id);

-- RLS
ALTER TABLE user_titles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view user_titles"
  ON user_titles FOR SELECT USING (true);

CREATE POLICY "System can grant titles"
  ON user_titles FOR INSERT WITH CHECK (auth.uid() = user_id);
```

### 14. tier_lists (티어리스트)

```sql
CREATE TABLE public.tier_lists (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  category TEXT,                      -- 콘텐츠 카테고리 필터
  tiers JSONB NOT NULL DEFAULT '{"S":[],"A":[],"B":[],"C":[],"D":[]}',
  is_public BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT timezone('utc', now()),
  updated_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

CREATE INDEX idx_tier_lists_user ON tier_lists(user_id);

-- RLS
ALTER TABLE tier_lists ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own tier_lists"
  ON tier_lists FOR SELECT USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can create tier_lists"
  ON tier_lists FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own tier_lists"
  ON tier_lists FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own tier_lists"
  ON tier_lists FOR DELETE USING (auth.uid() = user_id);
```

### 15. blind_game_scores (블라인드 게임 점수)

```sql
CREATE TABLE public.blind_game_scores (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  score INTEGER NOT NULL,
  max_streak INTEGER NOT NULL,
  played_at TIMESTAMPTZ DEFAULT timezone('utc', now())
);

CREATE INDEX idx_blind_game_user ON blind_game_scores(user_id);
CREATE INDEX idx_blind_game_score ON blind_game_scores(score DESC);

-- RLS
ALTER TABLE blind_game_scores ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view blind_game_scores"
  ON blind_game_scores FOR SELECT USING (true);

CREATE POLICY "Users can save own scores"
  ON blind_game_scores FOR INSERT WITH CHECK (auth.uid() = user_id);
```

---

## RLS 정책 요약

| 테이블 | SELECT | INSERT | UPDATE | DELETE |
|--------|--------|--------|--------|--------|
| profiles | 모두 | 본인 | 본인 | - |
| contents | 모두 | 인증된 사용자 | - | - |
| user_contents | 본인 | 본인 | 본인 | 본인 |
| records | 본인 | 본인 | 본인 | 본인 |
| follows | 모두 | 본인(follower) | - | 본인 |
| blocks | 본인(blocker) | 본인 | - | 본인 |
| user_social | 모두 | 본인 | 본인 | - |
| record_likes | 모두 | 본인 | - | 본인 |
| record_comments | 모두 | 본인 | 본인 | 본인 |
| user_scores | 모두 | 본인 | 본인 | - |
| score_logs | 본인 | - | - | - |
| titles | 모두 | - | - | - |
| user_titles | 모두 | 본인 | - | - |
| tier_lists | 본인/공개 | 본인 | 본인 | 본인 |
| blind_game_scores | 모두 | 본인 | - | - |

---

## 트리거 및 함수

### 프로필 자동 생성

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, nickname)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1))
  );

  INSERT INTO public.user_social (user_id) VALUES (NEW.id);
  INSERT INTO public.user_scores (user_id) VALUES (NEW.id);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

### 팔로우 카운트 동기화

```sql
CREATE OR REPLACE FUNCTION sync_follow_counts()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE user_social
    SET follower_count = follower_count + 1, updated_at = now()
    WHERE user_id = NEW.following_id;

    UPDATE user_social
    SET following_count = following_count + 1, updated_at = now()
    WHERE user_id = NEW.follower_id;

    -- 상호 팔로우 확인 → 친구 수 증가
    IF EXISTS (
      SELECT 1 FROM follows
      WHERE follower_id = NEW.following_id AND following_id = NEW.follower_id
    ) THEN
      UPDATE user_social
      SET friend_count = friend_count + 1
      WHERE user_id IN (NEW.follower_id, NEW.following_id);
    END IF;

  ELSIF TG_OP = 'DELETE' THEN
    UPDATE user_social
    SET follower_count = follower_count - 1, updated_at = now()
    WHERE user_id = OLD.following_id;

    UPDATE user_social
    SET following_count = following_count - 1, updated_at = now()
    WHERE user_id = OLD.follower_id;

    IF EXISTS (
      SELECT 1 FROM follows
      WHERE follower_id = OLD.following_id AND following_id = OLD.follower_id
    ) THEN
      UPDATE user_social
      SET friend_count = friend_count - 1
      WHERE user_id IN (OLD.follower_id, OLD.following_id);
    END IF;
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_follow_change
AFTER INSERT OR DELETE ON follows
FOR EACH ROW EXECUTE FUNCTION sync_follow_counts();
```

### 영향력 계산

```sql
CREATE OR REPLACE FUNCTION update_influence(p_user_id UUID)
RETURNS VOID AS $$
DECLARE
  v_friend_count INTEGER;
  v_follower_count INTEGER;
  v_total_score INTEGER;
  v_influence INTEGER;
BEGIN
  SELECT friend_count, follower_count
  INTO v_friend_count, v_follower_count
  FROM user_social
  WHERE user_id = p_user_id;

  SELECT total_score
  INTO v_total_score
  FROM user_scores
  WHERE user_id = p_user_id;

  -- 영향력 = (친구 × 10) + (팔로워 × 5) + 업적점수
  v_influence := (COALESCE(v_friend_count, 0) * 10) +
                 (COALESCE(v_follower_count, 0) * 5) +
                 COALESCE(v_total_score, 0);

  UPDATE user_social
  SET influence = v_influence, updated_at = now()
  WHERE user_id = p_user_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 테이블 생성 순서

마이그레이션 시 다음 순서로 생성:

1. `profiles` (auth.users 의존)
2. `contents`
3. `user_contents` (profiles, contents 의존)
4. `records` (profiles, contents 의존)
5. `follows` (profiles 의존)
6. `blocks` (profiles 의존)
7. `user_social` (profiles 의존)
8. `record_likes` (records, profiles 의존)
9. `record_comments` (records, profiles 의존)
10. `user_scores` (profiles 의존)
11. `score_logs` (profiles 의존)
12. `titles`
13. `user_titles` (profiles, titles 의존)
14. `tier_lists` (profiles 의존)
15. `blind_game_scores` (profiles 의존)

---

*01_데이터베이스_스키마.md - 최종 수정: 2025-12-07*
